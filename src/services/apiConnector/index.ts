import queue from "queue";
import { stat, Stats } from "fs";
import api from "../../layers/api";
import { Dispatch, SetStateAction } from "react";
import _uploadFile from "./_uploadFile";
import db from "../../layers/db";
import _handleUpload from "./_handleUpload";
import notifications from "../../layers/notifications";

export class ApiConnector {
	private static instance: ApiConnector;
	private q = queue({ results: [], concurrency: 4, autostart: true });
	private r = queue({ results: [], concurrency: 4, autostart: true });

	private constructor() {}

	public static getInstance(): ApiConnector {
		if (!ApiConnector.instance) {
			ApiConnector.instance = new ApiConnector();
		}

		return ApiConnector.instance;
	}

	public result(
		apiKey: string,
		files: string[],
		onFileFinish: (fileID: string, score: number) => void
	) {
		files.map((fileID) =>
			this.r.push(async (cb) => {
				try {
					const user = await db.getUser();

					if (user.remainingRequests) {
						const res = await api.result(apiKey, fileID);
						await db.updateRemainingRequests(--user.remainingRequests);
						onFileFinish(
							fileID,
							res.ScoreMalicious.length >= 7
								? parseFloat(res.ScoreMalicious.slice(0, 6)) * 100
								: parseFloat(res.ScoreMalicious) * 100
						);
					} else {
						notifications({
							type: "error",
							message: `could not get result for ${fileID}, no requests left`,
							title: "No requests left",
						});
						throw new Error("no requests");
					}
				} catch (error) {
					console.error(error);
					/* if (error.message === "still pending") {
						onFileFinish(fileID, -1);
					} */
					onFileFinish(fileID, -1);
				} finally {
					cb!(undefined, undefined);
				}
			})
		);
	}

	public upload(
		files: string[],
		apiKey: string,
		setFiles: Dispatch<SetStateAction<IFile[]>>,
		setRequests: Dispatch<SetStateAction<number>>,
		onQueueFinish: () => void,
		limit = 0
	) {
		files.map((filePath) => {
			this.q.push(async (cb) => {
				try {
					const user = await db.getUser();

					if (user.remainingRequests) {
						const s: Stats = await new Promise((resolve, reject) => {
							stat(filePath, (err, stats) => {
								if (!err && this._hasValidSize(stats)) {
									resolve(stats);
								} else {
									reject(err ? err : new Error("File is too large"));
								}
							});
						});

						const res = await _uploadFile(filePath, s.size, apiKey, limit);
						await _handleUpload(
							res,
							s.size,
							setFiles,
							setRequests,
							user.remainingRequests
						);
					} else {
						notifications({
							type: "error",
							message: `could not upload ${filePath}, no requests left`,
							title: "No requests left",
						});
						// await _handleNoRequests(filePath);
					}
				} catch (error) {
					console.error(error);
				} finally {
					cb!(undefined, undefined);
				}
			});

			this.q.once("end", function (err) {
				onQueueFinish();
			});
		});
	}

	private _hasValidSize(stats: Stats) {
		return stats.size < 16000000;
	}
}
