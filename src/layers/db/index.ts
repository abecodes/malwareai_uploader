import Datastore from "nedb-promises";
import { parse } from "path";

interface IDatabase {
	getFile: (id: string) => Promise<IFile>;
	getFileByPath: (path: string) => Promise<IFile>;
	getFiles: () => Promise<IFile[]>;
	getPendingFiles: () => Promise<IFile[]>;
	setFile: (
		id: string,
		path: string,
		result: number,
		readyAt: number,
		size: number
	) => Promise<IFile>;
	updateFileResult: (id: string, result: number) => Promise<number>;
	getUser: () => Promise<IUser>;
	setUser: (
		key: string,
		remainingRequests: number,
		limitReset: number,
		lastRequest: number,
		bandwidth: number
	) => Promise<IUser>;
	updateLastRequest: (lastRequest: number) => Promise<number>;
	updateLimitReset: (limitReset: number) => Promise<number>;
	updateRemainingRequests: (remainingRequests: number) => Promise<number>;
}

let db: {
	user: Datastore;
	files: Datastore;
};

export const init = () => {
	db = {
		user: Datastore.create(`malwareai.user.data`),
		files: Datastore.create(`malwareai.files.data`),
	};
};

export default {
	getFile: (id: string) => db.files.findOne<IFile>({ id }),
	getFileByPath: (path: string) => db.files.findOne<IFile>({ path }),
	getFiles: () => db.files.find<IFile>({}),
	getPendingFiles: () => db.files.find<IFile>({ result: -1 }),
	setFile: (
		id: string,
		path: string,
		result: number,
		readyAt: number,
		size: number
	) => {
		const p = parse(path);
		return db.files.insert<IFile>({
			id,
			path: path,
			fileExtension: p.ext,
			fileName: p.name,
			result,
			readyAt,
			size,
		});
	},
	updateFileResult: (id: string, result: number) =>
		db.files.update<IFile>({ id }, { $set: { result } }),
	getUser: () => db.user.findOne<IUser>({}),
	setUser: (
		key: string,
		remainingRequests: number,
		limitReset: number,
		lastRequest: number,
		bandwidth: number
	) =>
		db.user.insert<IUser>({
			key,
			remainingRequests,
			limitReset,
			lastRequest,
			bandwidth,
		}),
	updateLastRequest: (lastRequest: number) =>
		db.user.update<IUser>({}, { $set: { lastRequest } }),
	updateLimitReset: (limitReset: number) =>
		db.user.update<IUser>({}, { $set: { limitReset } }),
	updateRemainingRequests: (remainingRequests: number) =>
		db.user.update<IUser>({}, { $set: { remainingRequests } }),
} as IDatabase;
